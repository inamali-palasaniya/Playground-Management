generator client {
  provider = "prisma-client"
  output   = "../src/generated/client"
}

datasource db {
  provider = "postgresql"
}

model Game {
  id          Int          @id @default(autoincrement())
  name        String
  tournaments Tournament[]
}

model UserGroup {
  id    Int    @id @default(autoincrement())
  name  String
  users User[]
}

model User {
  id               Int            @id @default(autoincrement())
  name             String
  phone            String         @unique
  email            String?        @unique
  role             UserRole       @default(NORMAL)
  deposit_amount   Float          @default(0.0)
  group_id         Int?
  password         String?
  age              Int?
  user_type        UserType     @default(NORMAL)
  is_active        Boolean      @default(true)
  attendances      Attendance[]
  bowled_balls     BallEvent[]    @relation("Bowler")
  faced_balls      BallEvent[]    @relation("Striker")
  non_striker_balls BallEvent[]   @relation("NonStriker")
  fee_ledger       FeeLedger[]
  series_won_mots  Tournament[]   @relation("ManOfTheSeries")
  matches_won_motm Match[]        @relation("ManOfTheMatch")
  subscriptions    Subscription[]
  player_teams     TeamPlayer[]
  matches_as_striker Match[]      @relation("CurrentStriker")
  matches_as_non_striker Match[]  @relation("CurrentNonStriker")
  matches_as_bowler Match[]       @relation("CurrentBowler")
  createdAt        DateTime       @default(now())
  created_by_id    Int?
  created_by       User?          @relation("UserCreator", fields: [created_by_id], references: [id])
  created_users    User[]         @relation("UserCreator")
  
  created_attendances Attendance[] @relation("AttendanceCreator")
  created_ledgers     FeeLedger[]  @relation("LedgerCreator")
  created_expenses    Expense[]    @relation("ExpenseCreator")
  created_tournaments Tournament[] @relation("TournamentCreator")
  created_teams       Team[]       @relation("TeamCreator")
  created_matches     Match[]      @relation("MatchCreator")

  group            UserGroup?     @relation(fields: [group_id], references: [id])
  fines            UserFine[]
  permissions      Permission[]
  audit_logs       AuditLog[]
}

model SubscriptionPlan {
  id                  Int            @id @default(autoincrement())
  name                String         @unique
  rate_daily          Float?
  rate_monthly        Float?
  monthly_deposit_part Float?         @default(0)
  is_deposit_required Boolean        @default(false)
  createdAt           DateTime       @default(now())
  subscriptions       Subscription[]
}

model Subscription {
  id          Int                @id @default(autoincrement())
  user_id     Int
  plan_id     Int
  start_date  DateTime
  end_date    DateTime?
  amount_paid Float
  status      SubscriptionStatus @default(ACTIVE)
  createdAt   DateTime           @default(now())
  plan        SubscriptionPlan   @relation(fields: [plan_id], references: [id])
  user        User               @relation(fields: [user_id], references: [id], onDelete: Cascade)
  payment_frequency PaymentFrequency @default(MONTHLY)

  @@index([user_id])
  @@index([plan_id])
}

enum PaymentFrequency {
  DAILY
  MONTHLY
}

model Attendance {
  id                Int       @id @default(autoincrement())
  user_id           Int
  date              DateTime  @db.Date
  is_present        Boolean   @default(true)
  daily_fee_charged Float?
  createdAt         DateTime  @default(now())
  in_time           DateTime?
  location_lat      Float?
  location_lng      Float?
  out_time          DateTime?
  created_by_id     Int?
  created_by        User?     @relation("AttendanceCreator", fields: [created_by_id], references: [id])
  user              User      @relation(fields: [user_id], references: [id])


  @@index([user_id])
  @@index([date])
}

model FeeLedger {
  id        Int        @id @default(autoincrement())
  user_id   Int
  type             LedgerType
  transaction_type TransactionType @default(DEBIT)
  payment_method   PaymentMethod?
  amount           Float
  date             DateTime        @default(now())
  is_paid          Boolean         @default(false)
  notes            String?
  createdAt        DateTime        @default(now())
  created_by_id Int?
  created_by    User?      @relation("LedgerCreator", fields: [created_by_id], references: [id])
  user          User       @relation(fields: [user_id], references: [id])
  
  parent_ledger_id Int?
  parent_ledger    FeeLedger?  @relation("LedgerHierarchy", fields: [parent_ledger_id], references: [id])
  child_ledger     FeeLedger[] @relation("LedgerHierarchy")

  @@index([user_id])
  @@index([is_paid])
  @@index([parent_ledger_id])
}

model FineRule {
  id                    Int        @id @default(autoincrement())
  name                  String     @unique
  first_time_fine       Float
  subsequent_fine       Float      @default(0)
  createdAt             DateTime   @default(now())
  fines                 UserFine[]
}

model UserFine {
  id             Int      @id @default(autoincrement())
  user_id        Int
  rule_id        Int
  date           DateTime @default(now())
  occurrence     Int      @default(1)
  amount_charged Float
  createdAt      DateTime @default(now())
  rule           FineRule @relation(fields: [rule_id], references: [id])
  user           User     @relation(fields: [user_id], references: [id])

  @@index([user_id])
  @@index([rule_id])
}
model Expense {
  id            Int      @id @default(autoincrement())
  name          String
  category      String
  amount        Float
  date          DateTime @default(now())
  notes         String?
  createdAt     DateTime @default(now())
  created_by_id Int?
  created_by    User?    @relation("ExpenseCreator", fields: [created_by_id], references: [id])
}

model Tournament {
  id                   Int       @id @default(autoincrement())
  name                 String
  game_id              Int
  start_date           DateTime
  end_date             DateTime?
  man_of_the_series_id Int?
  matches              Match[]
  teams                Team[]
  createdAt            DateTime  @default(now())
  created_by_id        Int?
  game                 Game      @relation(fields: [game_id], references: [id])
  man_of_the_series    User?     @relation("ManOfTheSeries", fields: [man_of_the_series_id], references: [id])
  created_by           User?     @relation("TournamentCreator", fields: [created_by_id], references: [id])
}

model Team {
  id            Int          @id @default(autoincrement())
  name          String
  tournament_id Int
  matches_as_a  Match[]      @relation("TeamA")
  matches_as_b  Match[]      @relation("TeamB")
  toss_won      Match[]      @relation("TossWinner")
  matches_won   Match[]      @relation("MatchWinner")
  matches_batting Match[]      @relation("CurrentBattingTeam")
  createdAt     DateTime   @default(now())
  created_by_id Int?
  tournament    Tournament   @relation(fields: [tournament_id], references: [id])
  players       TeamPlayer[]
  created_by    User?      @relation("TeamCreator", fields: [created_by_id], references: [id])
}

model TeamPlayer {
  id      Int  @id @default(autoincrement())
  team_id Int
  user_id Int
  team    Team @relation(fields: [team_id], references: [id], onDelete: Cascade)
  user    User @relation(fields: [user_id], references: [id], onDelete: Cascade)
}

model Match {
  id                  Int         @id @default(autoincrement())
  tournament_id       Int
  team_a_id           Int
  team_b_id           Int
  start_time          DateTime
  status              MatchStatus @default(SCHEDULED)
  overs               Int         @default(20)
  current_innings     Int         @default(1)
  is_completed        Boolean     @default(false)
  
  // Toss & Result
  toss_winner_id      Int?
  toss_decision       String?     // "BAT" or "BOWL"
  winning_team_id     Int?
  result_description  String?     // e.g. "Won by 20 runs"

  man_of_the_match_id Int?

  // Current Live State
  current_striker_id     Int?
  current_non_striker_id Int?
  current_bowler_id      Int?
  current_batting_team_id Int?

  ball_events         BallEvent[]
  
  createdAt           DateTime    @default(now())
  created_by_id       Int?
  man_of_the_match    User?       @relation("ManOfTheMatch", fields: [man_of_the_match_id], references: [id])
  current_striker     User?       @relation("CurrentStriker", fields: [current_striker_id], references: [id])
  current_non_striker User?       @relation("CurrentNonStriker", fields: [current_non_striker_id], references: [id])
  current_bowler      User?       @relation("CurrentBowler", fields: [current_bowler_id], references: [id])
  current_batting_team Team?      @relation("CurrentBattingTeam", fields: [current_batting_team_id], references: [id])
  team_a              Team        @relation("TeamA", fields: [team_a_id], references: [id], onDelete: Cascade)
  team_b              Team        @relation("TeamB", fields: [team_b_id], references: [id], onDelete: Cascade)
  toss_winner         Team?       @relation("TossWinner", fields: [toss_winner_id], references: [id], onDelete: SetNull)
  winning_team        Team?       @relation("MatchWinner", fields: [winning_team_id], references: [id], onDelete: SetNull)
  tournament          Tournament  @relation(fields: [tournament_id], references: [id], onDelete: Cascade)
  created_by          User?       @relation("MatchCreator", fields: [created_by_id], references: [id])
}

model BallEvent {
  id              Int      @id @default(autoincrement())
  match_id        Int
  innings         Int      @default(1)
  over_number     Int
  ball_number     Int
  bowler_id       Int
  striker_id      Int
  non_striker_id  Int?     // Nullable for now to support legacy data if any
  batting_team_id Int?     // Nullable for legacy
  
  runs_scored     Int      @default(0)
  is_wicket       Boolean  @default(false)
  wicket_type     String?
  extras          Int      @default(0)
  extra_type      String?
  is_valid_ball   Boolean  @default(true)
  timestamp       DateTime @default(now())

  bowler          User     @relation("Bowler", fields: [bowler_id], references: [id])
  match           Match    @relation(fields: [match_id], references: [id], onDelete: Cascade)
  striker         User     @relation("Striker", fields: [striker_id], references: [id])
  non_striker     User?    @relation("NonStriker", fields: [non_striker_id], references: [id])
}

model Permission {
  id          Int     @id @default(autoincrement())
  user_id     Int
  module_name String
  can_add     Boolean @default(false)
  can_edit    Boolean @default(false)
  can_delete  Boolean @default(false)
  user        User    @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([user_id, module_name])
}

enum UserRole {
  MANAGEMENT
  NORMAL
  SUPER_ADMIN
}

enum LedgerType {
  DAILY_FEE
  MONTHLY_FEE
  FINE
  PAYMENT
  DEPOSIT
  SUBSCRIPTION
  DONATION
  MAINTENANCE
  MANUAL_FEE
  OTHER
}

enum UserType {
  STUDENT
  NON_EARNED
  SALARIED
  NORMAL
}

enum TransactionType {
  CREDIT
  DEBIT
}

enum PaymentMethod {
  CASH
  ONLINE
  UPI
  BANK_TRANSFER
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
}

enum MatchStatus {
  SCHEDULED
  LIVE
  COMPLETED
  ABANDONED
}

model AuditLog {
  id              Int      @id @default(autoincrement())
  entity_type     String
  entity_id       Int
  action          String   // CREATE, UPDATE, DELETE
  performed_by_id Int
  performed_by    User     @relation(fields: [performed_by_id], references: [id])
  details         Json?
  timestamp       DateTime @default(now())
}
